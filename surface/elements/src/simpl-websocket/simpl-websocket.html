<!--
/**
 * This file is part of SIMPL4(http://simpl4.org).
 *
 * 	Copyright [2014] [Manfred Sattler] <manfred@ms123.org>
 *
 * SIMPL4 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SIMPL4 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SIMPL4.  If not, see <http://www.gnu.org/licenses/>.
 */
-->
<polymer-element name="simpl-websocket" attributes="connected sendMessage recvMessage json jsonSend jsonReceive" constructor="SimplWebsocket">
	<template>
		<style>
			:host {
				display: none;
			}

		</style>
	</template>
	<script type="text/javascript">
		( function() {
			Polymer( "simpl-websocket", {
				connected: false,
				/**
				 * Should both sent and received data be interpreted as json and encoded/decoded ? Defaults to false.
				 * @public
				 * @type {Boolean}
				 */
				json: true,
				/**
				 * Should sent data be json-encoded, even if {{json}} is falsy ? Defaults to false.
				 * @public
				 * @type {Boolean}
				 */
				jsonSend: false,
				/**
				 * Should received data be json-decoded, even if {{json}} is falsy ? Defaults to false.
				 * @type {Boolean}
				 */
				jsonReceive: false,
				/**
				 * WebSocket object.
				 * @private
				 * @type {WebSocket}
				 */
				send: function( data ) {
					if ( !this.connected ) {
						throw new Error( "simpl-websocket.send(...): not connected." );
					}
					if ( this.json || this.jsonSend ) {
						data = JSON.stringify( data );
					}
					console.log( "socket:onNext:", data );
					this.socket.onNext( data );
				},
				sendPing: function() {
					if ( !this.connected ) return;
					console.debug( "Ping" );
					var message = {
						event: "ping",
						data: {}
					};
					this.send( message );
				},
				sendMessageChanged: function() {
					this.send( this.sendMessage );
				},
				close: function( reason ) {
					if ( this.ws ) {
						this.ws.close( reason );
						this.ws = null;
					}
					this.connected = false;
				},
				ready: function() {
					var password = simpl4.util.BaseManager.getPassword();
					var username = simpl4.util.BaseManager.getUser();
					var credentials = simpl4.util.Base64.encode( username + ":" + password );
					var uuid = this.generateUUID();
					var baseUrl = simpl4.util.BaseManager.getBaseUrl();
					baseUrl = baseUrl.replace( "http", "ws" );
					this.url = baseUrl + "/ws/xyz?service=xmpp&credentials=" + credentials + "&uuid=" + uuid;

					var open = Rx.Observer.create( ( function( e ) {
						console.info( 'websocket open' );
						this.connected = true;
						setInterval( ( function() {
							this.sendPing();
						} ).bind( this ), 1300000 );
					} ).bind( this ) );

					var closingObserver = Rx.Observer.create( ( function() {
						console.log( 'websocket is about to close' );
						this.connected = false;
					} ).bind( this ) );

					this.socket = this.fromWebSocket( this.url, open, closingObserver );
					console.log( "SOCKET:", this.socket );
					var self = this;
					this.socket.subscribe(
						function( e ) {
							var data = e.data;
							if ( this.json || this.jsonReceive ) {
								data = JSON.parse( data );
							}
							self.fire( "message", {
								data: data
							} );
							console.log( 'recv message: ', data );
							self.recvMessage = data;
						},
						function( e ) {
							console.error( 'error: ', e );
						},
						function() {
							console.info( 'websocket closed' );
							self.connected = false;
						}
					);
				},
				fromWebSocket: function( url, openObserver, closingObserver ) {
					if ( !WebSocket ) {
						throw new TypeError( 'WebSocket not implemented in your runtime.' );
					}

					var socket;

					var socketClose = function( code, reason ) {
						if ( socket ) {
							if ( closingObserver ) {
								closingObserver.onNext();
								closingObserver.onCompleted();
							}
							if ( !code ) {
								socket.close();
							} else {
								socket.close( code, reason );
							}
						}
					};

					var observable = new Rx.AnonymousObservable( function( obs ) {
						socket = new ReconnectingWebSocket( url, null, {
							debug: false,
							reconnectInterval: 50
						} );

						var openHandler = function( e ) {
							openObserver.onNext( e );
							openObserver.onCompleted();
							socket.removeEventListener( 'open', openHandler, false );
						};
						var messageHandler = function( e ) {
							obs.onNext( e );
						};
						var errHandler = function( e ) {
							obs.onError( e );
						};
						var closeHandler = function( e ) {
							console.log( "do not close", e );
							if ( e.code == null ) return;
							if ( e.code !== 1000 || !e.wasClean ) {
								return obs.onError( e );
							}
							obs.onCompleted();
						};

						openObserver && socket.addEventListener( 'open', openHandler, false );
						socket.addEventListener( 'message', messageHandler, false );
						socket.addEventListener( 'error', errHandler, false );
						socket.addEventListener( 'close', closeHandler, false );

						return function() {
							socketClose();

							socket.removeEventListener( 'message', messageHandler, false );
							socket.removeEventListener( 'error', errHandler, false );
							socket.removeEventListener( 'close', closeHandler, false );
						};
					} );

					var observer = Rx.Observer.create( function( data ) {
							socket.readyState === WebSocket.OPEN && socket.send( data );
						},
						function( e ) {
							if ( !e.code ) {
								throw new Error( 'no code specified. be sure to pass { code: ###, reason: "" } to onError()' );
							}

							socketClose( e.code, e.reason || '' );
						},
						function() {
							socketClose( 1000, '' );
						} );

					return Rx.Subject.create( observer, observable );
				},
				generateUUID: function() {
					var d = new Date().getTime();
					var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
						var r = ( d + Math.random() * 16 ) % 16 | 0;
						d = Math.floor( d / 16 );
						return ( c == 'x' ? r : ( r & 0x3 | 0x8 ) ).toString( 16 );
					} );
					return uuid;
				}
			} );
		} )();

	</script>
</polymer-element>
